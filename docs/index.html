---
layout: default
---
<style>
    * {
        box-sizing: border-box;
    }

    .column {
        float: left;
        width: 50%;
        padding: 5px;
    }

    /* Clearfix (clear floats) */
    .row::after {
        content: "";
        clear: both;
        display: table;
    }

    img {
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    figure figcaption {
        /*border: 1px dotted blue;*/
        text-align: center;
    }
</style>

<h1>SimBenchmark</h1>

<p>
    SimBenchmark is a project for benchmark of physics engines with contacts.
</p>

<h2>Introduction</h2>

<p>
    An accurate and fast simulation of contact dynamics is crucial for research on legged robots since the motion of legged robots is highly dependent on contact force generated by feet-terrain interaction.
    So far, a number of rigid body simulators with contact solvers has been introduced to the robotics society.
    However most state-of-the-art simulators face trade-off between reality of the simulation and simulation efficient.

    <figure>
        <img src="./img/anymal-walking.gif" alt="anymal-walking-raisim">
        <figcaption>Fig. 1. ANYmal walking in a simulation. <br>Image courtesy of Joonho Lee.</figcaption>
    </figure>
</p>
<p>
    <!-- <div class="row"> -->
    <!-- <div class="column"> -->
    <!-- <img src="./img/mujoco-humanoid.png"> -->
    <!--<figcaption>ANYmal PD control simulation (articulated robot system simulation)</figcaption>-->
    <!-- </div> -->
    <!-- <div class="column"> -->
    <!-- <img src="./img/mujoco-humanoid2.png"> -->
    <!--<figcaption>Zero gravity demo (Single body objects collision simulation)</figcaption>-->
    <!-- </div> -->
    <!-- </div> -->
</p>
<p>
    In this benchmark, we provide evaluation of the most commonly-used physics engines in various situations from single-bodies with a limited number of contacts to complex articulated robotic systems with PD control input.
    The main goal of this project is helping robotics researchers to select the best physics engine for their purposes.
</p>

<hr>
<h2>List of Physics Engines</h2>

<p>
    We evaluated the most widely-used physics engines for robotics and machine learning applications.<a href="#[1]">[1]</a>
    The list of the engines is as follows:
<ul>
    <li>RaiSim (unreleased)
        <ul><li><a href="about/sims.html#RaiSim"><b>What is RaiSim?</b></a></li></ul>
    </li>
    <li><a href="http://bulletphysics.org/">Bullet Physics <i>(Bullet)</i></a></li>
    <li><a href="http://www.ode.org/">Open Dynamics Engine <i>(ODE)</i></a></li>
    <li><a href="http://mujoco.org/">Multi-Joint dynamics with Contact <i>(MuJoCo)</i></a></li>
    <li><a href="https://dartsim.github.io/">Dynamic Animation and Robotics Toolkit <i>(DART)</i></a></li>
</ul>
</p>

<p>
    You can find more details about each engine and how they were used in our benchmark software <a href="about/sims.html">here</a>.
</p>

<div align="center">
    <table style="width:100%">
        <col width="15%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <col width="17%">
        <tr>
            <td></td>
            <th><small>RaiSim</small></th>
            <th><small>Bullet</small></th>
            <th><small>ODE</small></th>
            <th><small>MuJoCo</small></th>
            <th><small>DART</small></th>
        </tr>
        <tr>
            <th><small>Initial <br> release</small></th>
            <td><small>Unreleased</small></td>
            <td><small>2006</small></td>
            <td><small>2001</small></td>
            <td><small>2015</small></td>
            <td><small>2012</small></td>
        </tr>
        <tr>
            <th><small>Author</small></th>
            <td><small>J. Hwangbo<br>D. Kang</small></td>
            <td><small>E. Coumans</small></td>
            <td><small>R. Smith</small></td>
            <td><small>E. Todorov</small></td>
            <td><small>J. Lee et al</small></td>
        </tr>
        <tr>
            <th><small>License</small></th>
            <td><small>Proprietary</small></td>
            <td><small>Zlib<br>(open-source)</small></td>
            <td><small>GPL / BSD<br>(open-source)</small></td>
            <td><small>Proprietary</small></td>
            <td><small>BSD</small></td>
        </tr>
        <tr>
            <th><small>Main<br>purpose</small></th>
            <td><small>Robotics</small></td>
            <td><small>Game, Graphics</small></td>
            <td><small>Game, Graphics</small></td>
            <td><small>Robotics</small></td>
            <td><small>Robotics</small></td>
        </tr>
        <tr>
            <th><small>Language</small></th>
            <td><small>C++</small></td>
            <td><small>C++</small></td>
            <td><small>C++</small></td>
            <td><small>C</small></td>
            <td><small>C++</small></td>
        </tr>
        <tr>
            <th><small>API</small></th>
            <td><small>C++</small></td>
            <td><small>C++ / Python</small></td>
            <td><small>C</small></td>
            <td><small>C</small></td>
            <td><small>C++</small></td>
        </tr>
        <tr>
            <th><small>Contacts</small></th>
            <td><small>Hard</small></td>
            <td><small>Hard/Soft</small></td>
            <td><small>Hard/Soft</small></td>
            <td><small>Soft</small></td>
            <td><small>Hard</small></td>
        </tr>
        <tr>
            <th><small>Solver</small></th>
            <td><small>Bisection</small></td>
            <td><small>MLCP</small></td>
            <td><small>LCP</small></td>
            <td><small>Newton / PGS / CG</small></td>
            <td><small>LCP</small></td>
        </tr>
        <tr>
            <th><small>Integrator</small></th>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler</small></td>
            <td><small>Semi-implicit Euler / RK4</small></td>
            <td><small>Semi-implicit Euler</small></td>
        </tr>
        <tr>
            <th><small>Coordinates</small></th>
            <td><small>Minimal</small></td>
            <td><small>Minimal</small></td>
            <td><small>Maximal</small></td>
            <td><small>Minimal</small></td>
            <td><small>Minimal</small></td>
        </tr>
    </table>
</div>

<!--<p>-->
<!--As solving contact dynamics is NP-hard problem due to its non-convexity and discontinuity, physics engines model contact problem as relaxed problem that enables using efficient solving methods.    In order to make the problem tractable,-->
<!--Each physics engine use different contact model and contact solvers thus has different characteristics. Please read <a href="about/models.html">this page</a> for more details-->
<!--</p>-->

<hr>
<h2>Evaluation Metrics</h2>

<p>
    The error of the contact simulation is mostly caused by

<ol class="pa">
    <li>inaccurate impulse/force solution from contact solver</li>
    <li>inherited discretized error from numerical integration.</li>
</ol>

For iterative contact solvers, 1) can be reduced by increasing the number of iteration, and 2) can be reduced by decreasing timestep.
In both case, there is speed-accuracy trade-off.
</p>

<p>
    In order to evaluate the performance, we have to take into account whole speed-accuracy curve as proposed in <a href="#[2]">[2]</a>.

    In the following example of speed-accuracy curve plot, the ideal engine is on the top-right corner, besides most of the engines are represented as the curves sloping downwards from left to right.
    The better engine's curve locates upper-right than others, thus the engine 1 represented by curve 1 is better than the engine 2 represented by curve 2.

    <figure>
        <img src="img/plot-format.png" alt="plot-format">
        <figcaption>Fig. 2. Speed-accuracy curve format.</figcaption>
    </figure>
</p>

<p>
    Although our lack of knowledge on real physics, we use an analytical solution of object trajectory as a reference which is obtained from Newton's rigid body dynamics and Coulomb's friction cone model when it is applicable:
    for systems with single rigid body with small number of contacts, we find analytical solution of the object trajectory and investigate numerical errors from simulation.
    For complex systems, it may not be possible to find an analytical trajectory. In these cases, we investigate generic physical quantities such as total kinetic energy or linear momentum.
    Finally, we also investigate position level drift by measuring penetration error.
</p>

<p>
    More details of benchmark methodology is <a href="about/methodology.html">here</a>.
</p>

<hr>
<h2>Test and Results</h2>

<h3>Tests</h3>

<p>
<ul>
    <li><a href="rolling/index.html">Rolling test</a>: friction model test</li>
    <li><a href="bouncing/index.html">Bouncing test</a>: single-body elastic collision test</li>
    <li><a href="666/index.html">666 balls test</a>: single-body hard contact test</li>
    <li><a href="elastic666/index.html">Elastic 666 balls test</a>: single-body energy test</li>
    <!--<li><a href="kapla/kapla.html">Kapla test</a>: single-body stacking test</li>-->
    <li><a href="anymal/index.html">ANYmal PD control test</a>: articulated-robot-system speed test for quadrupedal robot</li>
    <li><a href="atlas/index.html">Atlas PD control test</a>: articulated-robot-system speed test for bipedal robot</li>
    <li><a href="anymal-momentum/index.html">ANYmal momentum test</a>: articulated-robot-system momentum test</li>
    <li><a href="anymal-energy/index.html">ANYmal energy test</a>: articulated-robot-system energy test</li>
</ul>
</p>

<h3>Summary of Results</h3>

<div align="center">
    <table style="width:100%">
        <col width="20%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <col width="16%">
        <tr>
            <th></th>
            <th>RaiSim</th>
            <th>Bullet</th>
            <th>ODE</th>
            <th>MuJoCo</th>
            <th>DART</th>
        </tr>
        <tr>
            <th>Rolling</th>
            <td>++</td>
            <td><font color="green">+++</font></td>
            <td><font color="red">-</font></td>
            <td>+</td>
            <td><font color="red">-</font></td>
        </tr>
        <tr>
            <th>Bouncing</th>
            <td><font color="green">++++</font></td>
            <td>++</td>
            <td>+++</td>
            <td><font color="red">-</font></td>
            <td>+</td>
        </tr>
        <tr>
            <th>666</th>
            <td><font color="green">+++</font></td>
            <td>+</td>
            <td>++</td>
            <td>+</td>
            <td><font color="red">x</font></td>
        </tr>
        <tr>
            <th>Elastic 666</th>
            <td><font color="green">+++</font></td>
            <td>+</td>
            <td>++</td>
            <td><font color="red">-</font></td>
            <td><font color="red">x</font></td>
        </tr>
        <tr>
            <th>ANYmal PD</th>
            <td><font color="green">+++++</font></td>
            <td>+++</td>
            <td>+</td>
            <td>++++</td>
            <td>++</td>
        </tr>
        <tr>
            <th>Atlas PD</th>
            <td><font color="green">+++++</font></td>
            <td>+++</td>
            <td>+</td>
            <td>++++</td>
            <td>++</td>
        </tr>
        <tr>
            <th rowspan="2">ANYmal<br>Momentum</th>
            <td rowspan="2">+++</td>
            <td rowspan="2">++</td>
            <td rowspan="2"><font color="green">+++++</font></td>
            <td>++++ <small>(RK4)</small></td>
            <td rowspan="2">+</td>
        </tr>
        <tr>
            <td>++ <small>(Euler)</small></td>
        </tr>
        <tr>
            <th rowspan="2">ANYmal<br>Energy</th>
            <td rowspan="2">++++</td>
            <td rowspan="2">+++</td>
            <td rowspan="2">++</td>
            <td><font color="green">+++++</font> <small>(RK4)</small></td>
            <td rowspan="2">+</td>
        </tr>
        <tr>
            <td>+++ <small>(Euler)</small></td>
        </tr>
    </table>
</div>

<p>
<ul>
    <li>more + is better
    <li><font color="green"><b>+</b></font>: best results
    <li><font color="red">-</font>: cannot simulate due to inaccurate model or software bug
    <li><font color="red">x</font>: simulation fails due to a software error
</ul>
</p>

<hr>

<!--<h2>Conclusion</h2>-->
<h2>Commentary</h2>

<p>
<ul>
    <li>Note that this benchmark is done by Dongho Kang and Jemin Hwangho who are the developers of RaiSim.</li>
    <li>If you have any concern, please contact <a href="mailto:kangd@ethz.ch">Dongho Kang</a>.</li>
</ul>
</p>

<h2>Acknowledgement</h2>

<p>
    Special thanks to Erwin Coumans.
</p>


<h2>References</h2>

<ol class="bib">
    <li id="[1]">
        <a href="https://arxiv.org/pdf/1402.7050.pdf">
            S. Ivaldi et al., "Tools for dynamics simulation of robots: a survey based on user feedback", 2014
        </a>
    </li>
    <li id="[2]">
        <a href="https://arxiv.org/pdf/1402.7050.pdf">
            Tom Erez et al., "Simulation Tools for Model-Based Robotics: Comparison of Bullet, Havok, MuJoCo, ODE and PhysX", 2015
        </a>
    </li>
</ol>